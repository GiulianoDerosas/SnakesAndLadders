{"ast":null,"code":"import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage',\n    STRING = 'string',\n    PX = 'px',\n    MOUSEOUT = 'mouseout',\n    MOUSELEAVE = 'mouseleave',\n    MOUSEOVER = 'mouseover',\n    MOUSEENTER = 'mouseenter',\n    MOUSEMOVE = 'mousemove',\n    MOUSEDOWN = 'mousedown',\n    MOUSEUP = 'mouseup',\n    POINTERMOVE = 'pointermove',\n    POINTERDOWN = 'pointerdown',\n    POINTERUP = 'pointerup',\n    POINTERCANCEL = 'pointercancel',\n    LOSTPOINTERCAPTURE = 'lostpointercapture',\n    POINTEROUT = 'pointerout',\n    POINTERLEAVE = 'pointerleave',\n    POINTEROVER = 'pointerover',\n    POINTERENTER = 'pointerenter',\n    CONTEXTMENU = 'contextmenu',\n    TOUCHSTART = 'touchstart',\n    TOUCHEND = 'touchend',\n    TOUCHMOVE = 'touchmove',\n    TOUCHCANCEL = 'touchcancel',\n    WHEEL = 'wheel',\n    MAX_LAYERS_NUMBER = 5,\n    EVENTS = [[MOUSEENTER, '_pointerenter'], [MOUSEDOWN, '_pointerdown'], [MOUSEMOVE, '_pointermove'], [MOUSEUP, '_pointerup'], [MOUSELEAVE, '_pointerleave'], [TOUCHSTART, '_pointerdown'], [TOUCHMOVE, '_pointermove'], [TOUCHEND, '_pointerup'], [TOUCHCANCEL, '_pointercancel'], [MOUSEOVER, '_pointerover'], [WHEEL, '_wheel'], [CONTEXTMENU, '_contextmenu'], [POINTERDOWN, '_pointerdown'], [POINTERMOVE, '_pointermove'], [POINTERUP, '_pointerup'], [POINTERCANCEL, '_pointercancel'], [LOSTPOINTERCAPTURE, '_lostpointercapture']];\nconst EVENTS_MAP = {\n  mouse: {\n    [POINTEROUT]: MOUSEOUT,\n    [POINTERLEAVE]: MOUSELEAVE,\n    [POINTEROVER]: MOUSEOVER,\n    [POINTERENTER]: MOUSEENTER,\n    [POINTERMOVE]: MOUSEMOVE,\n    [POINTERDOWN]: MOUSEDOWN,\n    [POINTERUP]: MOUSEUP,\n    [POINTERCANCEL]: 'mousecancel',\n    pointerclick: 'click',\n    pointerdblclick: 'dblclick'\n  },\n  touch: {\n    [POINTEROUT]: 'touchout',\n    [POINTERLEAVE]: 'touchleave',\n    [POINTEROVER]: 'touchover',\n    [POINTERENTER]: 'touchenter',\n    [POINTERMOVE]: TOUCHMOVE,\n    [POINTERDOWN]: TOUCHSTART,\n    [POINTERUP]: TOUCHEND,\n    [POINTERCANCEL]: TOUCHCANCEL,\n    pointerclick: 'tap',\n    pointerdblclick: 'dbltap'\n  },\n  pointer: {\n    [POINTEROUT]: POINTEROUT,\n    [POINTERLEAVE]: POINTERLEAVE,\n    [POINTEROVER]: POINTEROVER,\n    [POINTERENTER]: POINTERENTER,\n    [POINTERMOVE]: POINTERMOVE,\n    [POINTERDOWN]: POINTERDOWN,\n    [POINTERUP]: POINTERUP,\n    [POINTERCANCEL]: POINTERCANCEL,\n    pointerclick: 'pointerclick',\n    pointerdblclick: 'pointerdblclick'\n  }\n};\n\nconst getEventType = type => {\n  if (type.indexOf('pointer') >= 0) {\n    return 'pointer';\n  }\n\n  if (type.indexOf('touch') >= 0) {\n    return 'touch';\n  }\n\n  return 'mouse';\n};\n\nconst getEventsMap = eventType => {\n  const type = getEventType(eventType);\n\n  if (type === 'pointer') {\n    return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n  }\n\n  if (type === 'touch') {\n    return EVENTS_MAP.touch;\n  }\n\n  if (type === 'mouse') {\n    return EVENTS_MAP.mouse;\n  }\n};\n\nfunction checkNoClip(attrs = {}) {\n  if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n    Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n  }\n\n  return attrs;\n}\n\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n  constructor(config) {\n    super(checkNoClip(config));\n    this._pointerPositions = [];\n    this._changedPointerPositions = [];\n\n    this._buildDOM();\n\n    this._bindContentEvents();\n\n    stages.push(this);\n    this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n    this.on('visibleChange.konva', this._checkVisibility);\n    this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n      checkNoClip(this.attrs);\n    });\n\n    this._checkVisibility();\n  }\n\n  _validateAdd(child) {\n    const isLayer = child.getType() === 'Layer';\n    const isFastLayer = child.getType() === 'FastLayer';\n    const valid = isLayer || isFastLayer;\n\n    if (!valid) {\n      Util.throw('You may only add layers to the stage.');\n    }\n  }\n\n  _checkVisibility() {\n    if (!this.content) {\n      return;\n    }\n\n    const style = this.visible() ? '' : 'none';\n    this.content.style.display = style;\n  }\n\n  setContainer(container) {\n    if (typeof container === STRING) {\n      if (container.charAt(0) === '.') {\n        var className = container.slice(1);\n        container = document.getElementsByClassName(className)[0];\n      } else {\n        var id;\n\n        if (container.charAt(0) !== '#') {\n          id = container;\n        } else {\n          id = container.slice(1);\n        }\n\n        container = document.getElementById(id);\n      }\n\n      if (!container) {\n        throw 'Can not find container in document with id ' + id;\n      }\n    }\n\n    this._setAttr('container', container);\n\n    if (this.content) {\n      if (this.content.parentElement) {\n        this.content.parentElement.removeChild(this.content);\n      }\n\n      container.appendChild(this.content);\n    }\n\n    return this;\n  }\n\n  shouldDrawHit() {\n    return true;\n  }\n\n  clear() {\n    var layers = this.children,\n        len = layers.length,\n        n;\n\n    for (n = 0; n < len; n++) {\n      layers[n].clear();\n    }\n\n    return this;\n  }\n\n  clone(obj) {\n    if (!obj) {\n      obj = {};\n    }\n\n    obj.container = typeof document !== 'undefined' && document.createElement('div');\n    return Container.prototype.clone.call(this, obj);\n  }\n\n  destroy() {\n    super.destroy();\n    var content = this.content;\n\n    if (content && Util._isInDocument(content)) {\n      this.container().removeChild(content);\n    }\n\n    var index = stages.indexOf(this);\n\n    if (index > -1) {\n      stages.splice(index, 1);\n    }\n\n    return this;\n  }\n\n  getPointerPosition() {\n    const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n\n    if (!pos) {\n      Util.warn(NO_POINTERS_MESSAGE);\n      return null;\n    }\n\n    return {\n      x: pos.x,\n      y: pos.y\n    };\n  }\n\n  _getPointerById(id) {\n    return this._pointerPositions.find(p => p.id === id);\n  }\n\n  getPointersPositions() {\n    return this._pointerPositions;\n  }\n\n  getStage() {\n    return this;\n  }\n\n  getContent() {\n    return this.content;\n  }\n\n  _toKonvaCanvas(config) {\n    config = config || {};\n    config.x = config.x || 0;\n    config.y = config.y || 0;\n    config.width = config.width || this.width();\n    config.height = config.height || this.height();\n    var canvas = new SceneCanvas({\n      width: config.width,\n      height: config.height,\n      pixelRatio: config.pixelRatio || 1\n    });\n\n    var _context = canvas.getContext()._context;\n\n    var layers = this.children;\n\n    if (config.x || config.y) {\n      _context.translate(-1 * config.x, -1 * config.y);\n    }\n\n    layers.forEach(function (layer) {\n      if (!layer.isVisible()) {\n        return;\n      }\n\n      var layerCanvas = layer._toKonvaCanvas(config);\n\n      _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n    });\n    return canvas;\n  }\n\n  getIntersection(pos) {\n    if (!pos) {\n      return null;\n    }\n\n    var layers = this.children,\n        len = layers.length,\n        end = len - 1,\n        n;\n\n    for (n = end; n >= 0; n--) {\n      const shape = layers[n].getIntersection(pos);\n\n      if (shape) {\n        return shape;\n      }\n    }\n\n    return null;\n  }\n\n  _resizeDOM() {\n    var width = this.width();\n    var height = this.height();\n\n    if (this.content) {\n      this.content.style.width = width + PX;\n      this.content.style.height = height + PX;\n    }\n\n    this.bufferCanvas.setSize(width, height);\n    this.bufferHitCanvas.setSize(width, height);\n    this.children.forEach(layer => {\n      layer.setSize({\n        width,\n        height\n      });\n      layer.draw();\n    });\n  }\n\n  add(layer, ...rest) {\n    if (arguments.length > 1) {\n      for (var i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    super.add(layer);\n    var length = this.children.length;\n\n    if (length > MAX_LAYERS_NUMBER) {\n      Util.warn('The stage has ' + length + ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n    }\n\n    layer.setSize({\n      width: this.width(),\n      height: this.height()\n    });\n    layer.draw();\n\n    if (Konva.isBrowser) {\n      this.content.appendChild(layer.canvas._canvas);\n    }\n\n    return this;\n  }\n\n  getParent() {\n    return null;\n  }\n\n  getLayer() {\n    return null;\n  }\n\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n\n  getLayers() {\n    return this.children;\n  }\n\n  _bindContentEvents() {\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    EVENTS.forEach(([event, methodName]) => {\n      this.content.addEventListener(event, evt => {\n        this[methodName](evt);\n      });\n    });\n  }\n\n  _pointerenter(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n\n    this._fire(events.pointerenter, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n\n  _pointerover(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n\n    this._fire(events.pointerover, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n\n  _getTargetShape(evenType) {\n    let shape = this[evenType + 'targetShape'];\n\n    if (shape && !shape.getStage()) {\n      shape = null;\n    }\n\n    return shape;\n  }\n\n  _pointerleave(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n\n    var targetShape = this._getTargetShape(eventType);\n\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n\n    if (targetShape && eventsEnabled) {\n      targetShape._fireAndBubble(events.pointerout, {\n        evt: evt\n      });\n\n      targetShape._fireAndBubble(events.pointerleave, {\n        evt: evt\n      });\n\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n\n      this[eventType + 'targetShape'] = null;\n    } else if (eventsEnabled) {\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n\n      this._fire(events.pointerout, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n\n    this.pointerPos = undefined;\n    this._pointerPositions = [];\n  }\n\n  _pointerdown(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n    var triggeredOnShape = false;\n\n    this._changedPointerPositions.forEach(pos => {\n      var shape = this.getIntersection(pos);\n      DD.justDragged = false;\n      Konva['_' + eventType + 'ListenClick'] = true;\n      const hasShape = shape && shape.isListening();\n\n      if (!hasShape) {\n        return;\n      }\n\n      if (Konva.capturePointerEventsEnabled) {\n        shape.setPointerCapture(pos.id);\n      }\n\n      this[eventType + 'ClickStartShape'] = shape;\n\n      shape._fireAndBubble(events.pointerdown, {\n        evt: evt,\n        pointerId: pos.id\n      });\n\n      triggeredOnShape = true;\n      const isTouch = evt.type.indexOf('touch') >= 0;\n\n      if (shape.preventDefault() && evt.cancelable && isTouch) {\n        evt.preventDefault();\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointerdown, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._pointerPositions[0].id\n      });\n    }\n  }\n\n  _pointermove(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n      evt.preventDefault();\n    }\n\n    this.setPointersPositions(evt);\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n\n    if (!eventsEnabled) {\n      return;\n    }\n\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n\n    var targetShape = this._getTargetShape(eventType);\n\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      var differentTarget = targetShape !== shape;\n\n      if (differentTarget && targetShape) {\n        targetShape._fireAndBubble(events.pointerout, event, shape);\n\n        targetShape._fireAndBubble(events.pointerleave, event, shape);\n      }\n\n      if (shape) {\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n\n        processedShapesIds[shape._id] = true;\n      }\n\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n\n        if (differentTarget) {\n          shape._fireAndBubble(events.pointerover, event, targetShape);\n\n          shape._fireAndBubble(events.pointerenter, event, targetShape);\n\n          this[eventType + 'targetShape'] = shape;\n        }\n\n        shape._fireAndBubble(events.pointermove, event);\n      } else {\n        if (targetShape) {\n          this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n\n          this[eventType + 'targetShape'] = null;\n        }\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointermove, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n  }\n\n  _pointerup(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n    const clickStartShape = this[eventType + 'ClickStartShape'];\n    const clickEndShape = this[eventType + 'ClickEndShape'];\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n\n      if (shape) {\n        shape.releaseCapture(pos.id);\n\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n\n        processedShapesIds[shape._id] = true;\n      }\n\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      let fireDblClick = false;\n\n      if (Konva['_' + eventType + 'InDblClickWindow']) {\n        fireDblClick = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      } else if (!DD.justDragged) {\n        Konva['_' + eventType + 'InDblClickWindow'] = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      }\n\n      this[eventType + 'DblTimeout'] = setTimeout(function () {\n        Konva['_' + eventType + 'InDblClickWindow'] = false;\n      }, Konva.dblClickWindow);\n\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n        this[eventType + 'ClickEndShape'] = shape;\n\n        shape._fireAndBubble(events.pointerup, event);\n\n        if (Konva['_' + eventType + 'ListenClick'] && clickStartShape && clickStartShape === shape) {\n          shape._fireAndBubble(events.pointerclick, event);\n\n          if (fireDblClick && clickEndShape && clickEndShape === shape) {\n            shape._fireAndBubble(events.pointerdblclick, event);\n          }\n        }\n      } else {\n        this[eventType + 'ClickEndShape'] = null;\n\n        if (Konva['_' + eventType + 'ListenClick']) {\n          this._fire(events.pointerclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n\n        if (fireDblClick) {\n          this._fire(events.pointerdblclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointerup, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n\n    Konva['_' + eventType + 'ListenClick'] = false;\n\n    if (evt.cancelable) {\n      evt.preventDefault();\n    }\n  }\n\n  _contextmenu(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(CONTEXTMENU, {\n        evt: evt\n      });\n    } else {\n      this._fire(CONTEXTMENU, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n\n  _wheel(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(WHEEL, {\n        evt: evt\n      });\n    } else {\n      this._fire(WHEEL, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n\n  _pointercancel(evt) {\n    this.setPointersPositions(evt);\n    const shape = PointerEvents.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());\n\n    if (shape) {\n      shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n    }\n\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n\n  _lostpointercapture(evt) {\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n\n  setPointersPositions(evt) {\n    var contentPosition = this._getContentPosition(),\n        x = null,\n        y = null;\n\n    evt = evt ? evt : window.event;\n\n    if (evt.touches !== undefined) {\n      this._pointerPositions = [];\n      this._changedPointerPositions = [];\n      Array.prototype.forEach.call(evt.touches, touch => {\n        this._pointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n      Array.prototype.forEach.call(evt.changedTouches || evt.touches, touch => {\n        this._changedPointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n    } else {\n      x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n      y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n      this.pointerPos = {\n        x: x,\n        y: y\n      };\n      this._pointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n      this._changedPointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n    }\n  }\n\n  _setPointerPosition(evt) {\n    Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n    this.setPointersPositions(evt);\n  }\n\n  _getContentPosition() {\n    if (!this.content || !this.content.getBoundingClientRect) {\n      return {\n        top: 0,\n        left: 0,\n        scaleX: 1,\n        scaleY: 1\n      };\n    }\n\n    var rect = this.content.getBoundingClientRect();\n    return {\n      top: rect.top,\n      left: rect.left,\n      scaleX: rect.width / this.content.clientWidth || 1,\n      scaleY: rect.height / this.content.clientHeight || 1\n    };\n  }\n\n  _buildDOM() {\n    this.bufferCanvas = new SceneCanvas({\n      width: this.width(),\n      height: this.height()\n    });\n    this.bufferHitCanvas = new HitCanvas({\n      pixelRatio: 1,\n      width: this.width(),\n      height: this.height()\n    });\n\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    var container = this.container();\n\n    if (!container) {\n      throw 'Stage has no container. A container is required.';\n    }\n\n    container.innerHTML = '';\n    this.content = document.createElement('div');\n    this.content.style.position = 'relative';\n    this.content.style.userSelect = 'none';\n    this.content.className = 'konvajs-content';\n    this.content.setAttribute('role', 'presentation');\n    container.appendChild(this.content);\n\n    this._resizeDOM();\n  }\n\n  cache() {\n    Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n    return this;\n  }\n\n  clearCache() {\n    return this;\n  }\n\n  batchDraw() {\n    this.getChildren().forEach(function (layer) {\n      layer.batchDraw();\n    });\n    return this;\n  }\n\n}\nStage.prototype.nodeType = STAGE;\n\n_registerNode(Stage);\n\nFactory.addGetterSetter(Stage, 'container');","map":{"version":3,"sources":["/Users/stevec/Codeclan_Work/Group_Project/SnakesAndLadders/client/node_modules/konva/lib/Stage.js"],"names":["Util","Factory","Container","Konva","SceneCanvas","HitCanvas","DD","_registerNode","PointerEvents","STAGE","STRING","PX","MOUSEOUT","MOUSELEAVE","MOUSEOVER","MOUSEENTER","MOUSEMOVE","MOUSEDOWN","MOUSEUP","POINTERMOVE","POINTERDOWN","POINTERUP","POINTERCANCEL","LOSTPOINTERCAPTURE","POINTEROUT","POINTERLEAVE","POINTEROVER","POINTERENTER","CONTEXTMENU","TOUCHSTART","TOUCHEND","TOUCHMOVE","TOUCHCANCEL","WHEEL","MAX_LAYERS_NUMBER","EVENTS","EVENTS_MAP","mouse","pointerclick","pointerdblclick","touch","pointer","getEventType","type","indexOf","getEventsMap","eventType","pointerEventsEnabled","checkNoClip","attrs","clipFunc","clipWidth","clipHeight","warn","NO_POINTERS_MESSAGE","stages","Stage","constructor","config","_pointerPositions","_changedPointerPositions","_buildDOM","_bindContentEvents","push","on","_resizeDOM","_checkVisibility","_validateAdd","child","isLayer","getType","isFastLayer","valid","throw","content","style","visible","display","setContainer","container","charAt","className","slice","document","getElementsByClassName","id","getElementById","_setAttr","parentElement","removeChild","appendChild","shouldDrawHit","clear","layers","children","len","length","n","clone","obj","createElement","prototype","call","destroy","_isInDocument","index","splice","getPointerPosition","pos","x","y","_getPointerById","find","p","getPointersPositions","getStage","getContent","_toKonvaCanvas","width","height","canvas","pixelRatio","_context","getContext","translate","forEach","layer","isVisible","layerCanvas","drawImage","_canvas","getWidth","getPixelRatio","getHeight","getIntersection","end","shape","bufferCanvas","setSize","bufferHitCanvas","draw","add","rest","arguments","i","isBrowser","getParent","getLayer","hasPointerCapture","pointerId","setPointerCapture","releaseCapture","getLayers","event","methodName","addEventListener","evt","_pointerenter","setPointersPositions","events","_fire","pointerenter","target","currentTarget","_pointerover","pointerover","_getTargetShape","evenType","_pointerleave","targetShape","eventsEnabled","isDragging","hitOnDragEnabled","_fireAndBubble","pointerout","pointerleave","pointerPos","undefined","_pointerdown","triggeredOnShape","justDragged","hasShape","isListening","capturePointerEventsEnabled","pointerdown","isTouch","preventDefault","cancelable","_pointermove","node","processedShapesIds","getCapturedShape","differentTarget","_id","pointermove","_pointerup","clickStartShape","clickEndShape","fireDblClick","clearTimeout","setTimeout","dblClickWindow","pointerup","_contextmenu","_wheel","_pointercancel","createEvent","_lostpointercapture","contentPosition","_getContentPosition","window","touches","Array","identifier","clientX","left","scaleX","clientY","top","scaleY","changedTouches","_getFirstPointerId","_setPointerPosition","getBoundingClientRect","rect","clientWidth","clientHeight","innerHTML","position","userSelect","setAttribute","cache","clearCache","batchDraw","getChildren","nodeType","addGetterSetter"],"mappings":"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","sourcesContent":["import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [\n    [MOUSEENTER, '_pointerenter'],\n    [MOUSEDOWN, '_pointerdown'],\n    [MOUSEMOVE, '_pointermove'],\n    [MOUSEUP, '_pointerup'],\n    [MOUSELEAVE, '_pointerleave'],\n    [TOUCHSTART, '_pointerdown'],\n    [TOUCHMOVE, '_pointermove'],\n    [TOUCHEND, '_pointerup'],\n    [TOUCHCANCEL, '_pointercancel'],\n    [MOUSEOVER, '_pointerover'],\n    [WHEEL, '_wheel'],\n    [CONTEXTMENU, '_contextmenu'],\n    [POINTERDOWN, '_pointerdown'],\n    [POINTERMOVE, '_pointermove'],\n    [POINTERUP, '_pointerup'],\n    [POINTERCANCEL, '_pointercancel'],\n    [LOSTPOINTERCAPTURE, '_lostpointercapture'],\n];\nconst EVENTS_MAP = {\n    mouse: {\n        [POINTEROUT]: MOUSEOUT,\n        [POINTERLEAVE]: MOUSELEAVE,\n        [POINTEROVER]: MOUSEOVER,\n        [POINTERENTER]: MOUSEENTER,\n        [POINTERMOVE]: MOUSEMOVE,\n        [POINTERDOWN]: MOUSEDOWN,\n        [POINTERUP]: MOUSEUP,\n        [POINTERCANCEL]: 'mousecancel',\n        pointerclick: 'click',\n        pointerdblclick: 'dblclick',\n    },\n    touch: {\n        [POINTEROUT]: 'touchout',\n        [POINTERLEAVE]: 'touchleave',\n        [POINTEROVER]: 'touchover',\n        [POINTERENTER]: 'touchenter',\n        [POINTERMOVE]: TOUCHMOVE,\n        [POINTERDOWN]: TOUCHSTART,\n        [POINTERUP]: TOUCHEND,\n        [POINTERCANCEL]: TOUCHCANCEL,\n        pointerclick: 'tap',\n        pointerdblclick: 'dbltap',\n    },\n    pointer: {\n        [POINTEROUT]: POINTEROUT,\n        [POINTERLEAVE]: POINTERLEAVE,\n        [POINTEROVER]: POINTEROVER,\n        [POINTERENTER]: POINTERENTER,\n        [POINTERMOVE]: POINTERMOVE,\n        [POINTERDOWN]: POINTERDOWN,\n        [POINTERUP]: POINTERUP,\n        [POINTERCANCEL]: POINTERCANCEL,\n        pointerclick: 'pointerclick',\n        pointerdblclick: 'pointerdblclick',\n    },\n};\nconst getEventType = (type) => {\n    if (type.indexOf('pointer') >= 0) {\n        return 'pointer';\n    }\n    if (type.indexOf('touch') >= 0) {\n        return 'touch';\n    }\n    return 'mouse';\n};\nconst getEventsMap = (eventType) => {\n    const type = getEventType(eventType);\n    if (type === 'pointer') {\n        return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n    }\n    if (type === 'touch') {\n        return EVENTS_MAP.touch;\n    }\n    if (type === 'mouse') {\n        return EVENTS_MAP.mouse;\n    }\n};\nfunction checkNoClip(attrs = {}) {\n    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n        Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n    }\n    return attrs;\n}\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n    constructor(config) {\n        super(checkNoClip(config));\n        this._pointerPositions = [];\n        this._changedPointerPositions = [];\n        this._buildDOM();\n        this._bindContentEvents();\n        stages.push(this);\n        this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n        this.on('visibleChange.konva', this._checkVisibility);\n        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n            checkNoClip(this.attrs);\n        });\n        this._checkVisibility();\n    }\n    _validateAdd(child) {\n        const isLayer = child.getType() === 'Layer';\n        const isFastLayer = child.getType() === 'FastLayer';\n        const valid = isLayer || isFastLayer;\n        if (!valid) {\n            Util.throw('You may only add layers to the stage.');\n        }\n    }\n    _checkVisibility() {\n        if (!this.content) {\n            return;\n        }\n        const style = this.visible() ? '' : 'none';\n        this.content.style.display = style;\n    }\n    setContainer(container) {\n        if (typeof container === STRING) {\n            if (container.charAt(0) === '.') {\n                var className = container.slice(1);\n                container = document.getElementsByClassName(className)[0];\n            }\n            else {\n                var id;\n                if (container.charAt(0) !== '#') {\n                    id = container;\n                }\n                else {\n                    id = container.slice(1);\n                }\n                container = document.getElementById(id);\n            }\n            if (!container) {\n                throw 'Can not find container in document with id ' + id;\n            }\n        }\n        this._setAttr('container', container);\n        if (this.content) {\n            if (this.content.parentElement) {\n                this.content.parentElement.removeChild(this.content);\n            }\n            container.appendChild(this.content);\n        }\n        return this;\n    }\n    shouldDrawHit() {\n        return true;\n    }\n    clear() {\n        var layers = this.children, len = layers.length, n;\n        for (n = 0; n < len; n++) {\n            layers[n].clear();\n        }\n        return this;\n    }\n    clone(obj) {\n        if (!obj) {\n            obj = {};\n        }\n        obj.container =\n            typeof document !== 'undefined' && document.createElement('div');\n        return Container.prototype.clone.call(this, obj);\n    }\n    destroy() {\n        super.destroy();\n        var content = this.content;\n        if (content && Util._isInDocument(content)) {\n            this.container().removeChild(content);\n        }\n        var index = stages.indexOf(this);\n        if (index > -1) {\n            stages.splice(index, 1);\n        }\n        return this;\n    }\n    getPointerPosition() {\n        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n        if (!pos) {\n            Util.warn(NO_POINTERS_MESSAGE);\n            return null;\n        }\n        return {\n            x: pos.x,\n            y: pos.y,\n        };\n    }\n    _getPointerById(id) {\n        return this._pointerPositions.find((p) => p.id === id);\n    }\n    getPointersPositions() {\n        return this._pointerPositions;\n    }\n    getStage() {\n        return this;\n    }\n    getContent() {\n        return this.content;\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        config.x = config.x || 0;\n        config.y = config.y || 0;\n        config.width = config.width || this.width();\n        config.height = config.height || this.height();\n        var canvas = new SceneCanvas({\n            width: config.width,\n            height: config.height,\n            pixelRatio: config.pixelRatio || 1,\n        });\n        var _context = canvas.getContext()._context;\n        var layers = this.children;\n        if (config.x || config.y) {\n            _context.translate(-1 * config.x, -1 * config.y);\n        }\n        layers.forEach(function (layer) {\n            if (!layer.isVisible()) {\n                return;\n            }\n            var layerCanvas = layer._toKonvaCanvas(config);\n            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n        });\n        return canvas;\n    }\n    getIntersection(pos) {\n        if (!pos) {\n            return null;\n        }\n        var layers = this.children, len = layers.length, end = len - 1, n;\n        for (n = end; n >= 0; n--) {\n            const shape = layers[n].getIntersection(pos);\n            if (shape) {\n                return shape;\n            }\n        }\n        return null;\n    }\n    _resizeDOM() {\n        var width = this.width();\n        var height = this.height();\n        if (this.content) {\n            this.content.style.width = width + PX;\n            this.content.style.height = height + PX;\n        }\n        this.bufferCanvas.setSize(width, height);\n        this.bufferHitCanvas.setSize(width, height);\n        this.children.forEach((layer) => {\n            layer.setSize({ width, height });\n            layer.draw();\n        });\n    }\n    add(layer, ...rest) {\n        if (arguments.length > 1) {\n            for (var i = 0; i < arguments.length; i++) {\n                this.add(arguments[i]);\n            }\n            return this;\n        }\n        super.add(layer);\n        var length = this.children.length;\n        if (length > MAX_LAYERS_NUMBER) {\n            Util.warn('The stage has ' +\n                length +\n                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n        }\n        layer.setSize({ width: this.width(), height: this.height() });\n        layer.draw();\n        if (Konva.isBrowser) {\n            this.content.appendChild(layer.canvas._canvas);\n        }\n        return this;\n    }\n    getParent() {\n        return null;\n    }\n    getLayer() {\n        return null;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n    getLayers() {\n        return this.children;\n    }\n    _bindContentEvents() {\n        if (!Konva.isBrowser) {\n            return;\n        }\n        EVENTS.forEach(([event, methodName]) => {\n            this.content.addEventListener(event, (evt) => {\n                this[methodName](evt);\n            });\n        });\n    }\n    _pointerenter(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerenter, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _pointerover(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _getTargetShape(evenType) {\n        let shape = this[evenType + 'targetShape'];\n        if (shape && !shape.getStage()) {\n            shape = null;\n        }\n        return shape;\n    }\n    _pointerleave(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var targetShape = this._getTargetShape(eventType);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (targetShape && eventsEnabled) {\n            targetShape._fireAndBubble(events.pointerout, { evt: evt });\n            targetShape._fireAndBubble(events.pointerleave, { evt: evt });\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this[eventType + 'targetShape'] = null;\n        }\n        else if (eventsEnabled) {\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this._fire(events.pointerout, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n        this.pointerPos = undefined;\n        this._pointerPositions = [];\n    }\n    _pointerdown(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            var shape = this.getIntersection(pos);\n            DD.justDragged = false;\n            Konva['_' + eventType + 'ListenClick'] = true;\n            const hasShape = shape && shape.isListening();\n            if (!hasShape) {\n                return;\n            }\n            if (Konva.capturePointerEventsEnabled) {\n                shape.setPointerCapture(pos.id);\n            }\n            this[eventType + 'ClickStartShape'] = shape;\n            shape._fireAndBubble(events.pointerdown, {\n                evt: evt,\n                pointerId: pos.id,\n            });\n            triggeredOnShape = true;\n            const isTouch = evt.type.indexOf('touch') >= 0;\n            if (shape.preventDefault() && evt.cancelable && isTouch) {\n                evt.preventDefault();\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerdown, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._pointerPositions[0].id,\n            });\n        }\n    }\n    _pointermove(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n            evt.preventDefault();\n        }\n        this.setPointersPositions(evt);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (!eventsEnabled) {\n            return;\n        }\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        var targetShape = this._getTargetShape(eventType);\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            var differentTarget = targetShape !== shape;\n            if (differentTarget && targetShape) {\n                targetShape._fireAndBubble(events.pointerout, event, shape);\n                targetShape._fireAndBubble(events.pointerleave, event, shape);\n            }\n            if (shape) {\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                if (differentTarget) {\n                    shape._fireAndBubble(events.pointerover, event, targetShape);\n                    shape._fireAndBubble(events.pointerenter, event, targetShape);\n                    this[eventType + 'targetShape'] = shape;\n                }\n                shape._fireAndBubble(events.pointermove, event);\n            }\n            else {\n                if (targetShape) {\n                    this._fire(events.pointerover, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                    this[eventType + 'targetShape'] = null;\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointermove, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n    }\n    _pointerup(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        const clickStartShape = this[eventType + 'ClickStartShape'];\n        const clickEndShape = this[eventType + 'ClickEndShape'];\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            if (shape) {\n                shape.releaseCapture(pos.id);\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            let fireDblClick = false;\n            if (Konva['_' + eventType + 'InDblClickWindow']) {\n                fireDblClick = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            else if (!DD.justDragged) {\n                Konva['_' + eventType + 'InDblClickWindow'] = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            this[eventType + 'DblTimeout'] = setTimeout(function () {\n                Konva['_' + eventType + 'InDblClickWindow'] = false;\n            }, Konva.dblClickWindow);\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                this[eventType + 'ClickEndShape'] = shape;\n                shape._fireAndBubble(events.pointerup, event);\n                if (Konva['_' + eventType + 'ListenClick'] &&\n                    clickStartShape &&\n                    clickStartShape === shape) {\n                    shape._fireAndBubble(events.pointerclick, event);\n                    if (fireDblClick && clickEndShape && clickEndShape === shape) {\n                        shape._fireAndBubble(events.pointerdblclick, event);\n                    }\n                }\n            }\n            else {\n                this[eventType + 'ClickEndShape'] = null;\n                if (Konva['_' + eventType + 'ListenClick']) {\n                    this._fire(events.pointerclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n                if (fireDblClick) {\n                    this._fire(events.pointerdblclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerup, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n        Konva['_' + eventType + 'ListenClick'] = false;\n        if (evt.cancelable) {\n            evt.preventDefault();\n        }\n    }\n    _contextmenu(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(CONTEXTMENU, { evt: evt });\n        }\n        else {\n            this._fire(CONTEXTMENU, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _wheel(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(WHEEL, { evt: evt });\n        }\n        else {\n            this._fire(WHEEL, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _pointercancel(evt) {\n        this.setPointersPositions(evt);\n        const shape = PointerEvents.getCapturedShape(evt.pointerId) ||\n            this.getIntersection(this.getPointerPosition());\n        if (shape) {\n            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n        }\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    _lostpointercapture(evt) {\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    setPointersPositions(evt) {\n        var contentPosition = this._getContentPosition(), x = null, y = null;\n        evt = evt ? evt : window.event;\n        if (evt.touches !== undefined) {\n            this._pointerPositions = [];\n            this._changedPointerPositions = [];\n            Array.prototype.forEach.call(evt.touches, (touch) => {\n                this._pointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {\n                this._changedPointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n        }\n        else {\n            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n            this.pointerPos = {\n                x: x,\n                y: y,\n            };\n            this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];\n            this._changedPointerPositions = [\n                { x, y, id: Util._getFirstPointerId(evt) },\n            ];\n        }\n    }\n    _setPointerPosition(evt) {\n        Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n        this.setPointersPositions(evt);\n    }\n    _getContentPosition() {\n        if (!this.content || !this.content.getBoundingClientRect) {\n            return {\n                top: 0,\n                left: 0,\n                scaleX: 1,\n                scaleY: 1,\n            };\n        }\n        var rect = this.content.getBoundingClientRect();\n        return {\n            top: rect.top,\n            left: rect.left,\n            scaleX: rect.width / this.content.clientWidth || 1,\n            scaleY: rect.height / this.content.clientHeight || 1,\n        };\n    }\n    _buildDOM() {\n        this.bufferCanvas = new SceneCanvas({\n            width: this.width(),\n            height: this.height(),\n        });\n        this.bufferHitCanvas = new HitCanvas({\n            pixelRatio: 1,\n            width: this.width(),\n            height: this.height(),\n        });\n        if (!Konva.isBrowser) {\n            return;\n        }\n        var container = this.container();\n        if (!container) {\n            throw 'Stage has no container. A container is required.';\n        }\n        container.innerHTML = '';\n        this.content = document.createElement('div');\n        this.content.style.position = 'relative';\n        this.content.style.userSelect = 'none';\n        this.content.className = 'konvajs-content';\n        this.content.setAttribute('role', 'presentation');\n        container.appendChild(this.content);\n        this._resizeDOM();\n    }\n    cache() {\n        Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n        return this;\n    }\n    clearCache() {\n        return this;\n    }\n    batchDraw() {\n        this.getChildren().forEach(function (layer) {\n            layer.batchDraw();\n        });\n        return this;\n    }\n}\nStage.prototype.nodeType = STAGE;\n_registerNode(Stage);\nFactory.addGetterSetter(Stage, 'container');\n"]},"metadata":{},"sourceType":"module"}