{"ast":null,"code":"import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '',\n    NORMAL = 'normal';\n\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\n\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\n\nexport class TextPath extends Shape {\n  constructor(config) {\n    super(config);\n    this.dummyCanvas = Util.createCanvasElement();\n    this.dataArray = [];\n    this.dataArray = Path.parsePathData(this.attrs.data);\n    this.on('dataChange.konva', function () {\n      this.dataArray = Path.parsePathData(this.attrs.data);\n\n      this._setTextData();\n    });\n    this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva', this._setTextData);\n\n    this._setTextData();\n  }\n\n  _sceneFunc(context) {\n    context.setAttr('font', this._getContextFont());\n    context.setAttr('textBaseline', this.textBaseline());\n    context.setAttr('textAlign', 'left');\n    context.save();\n    var textDecoration = this.textDecoration();\n    var fill = this.fill();\n    var fontSize = this.fontSize();\n    var glyphInfo = this.glyphInfo;\n\n    if (textDecoration === 'underline') {\n      context.beginPath();\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      context.save();\n      var p0 = glyphInfo[i].p0;\n      context.translate(p0.x, p0.y);\n      context.rotate(glyphInfo[i].rotation);\n      this.partialText = glyphInfo[i].text;\n      context.fillStrokeShape(this);\n\n      if (textDecoration === 'underline') {\n        if (i === 0) {\n          context.moveTo(0, fontSize / 2 + 1);\n        }\n\n        context.lineTo(fontSize, fontSize / 2 + 1);\n      }\n\n      context.restore();\n    }\n\n    if (textDecoration === 'underline') {\n      context.strokeStyle = fill;\n      context.lineWidth = fontSize / 20;\n      context.stroke();\n    }\n\n    context.restore();\n  }\n\n  _hitFunc(context) {\n    context.beginPath();\n    var glyphInfo = this.glyphInfo;\n\n    if (glyphInfo.length >= 1) {\n      var p0 = glyphInfo[0].p0;\n      context.moveTo(p0.x, p0.y);\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      var p1 = glyphInfo[i].p1;\n      context.lineTo(p1.x, p1.y);\n    }\n\n    context.setAttr('lineWidth', this.fontSize());\n    context.setAttr('strokeStyle', this.colorKey);\n    context.stroke();\n  }\n\n  getTextWidth() {\n    return this.textWidth;\n  }\n\n  getTextHeight() {\n    Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n    return this.textHeight;\n  }\n\n  setText(text) {\n    return Text.prototype.setText.call(this, text);\n  }\n\n  _getContextFont() {\n    return Text.prototype._getContextFont.call(this);\n  }\n\n  _getTextSize(text) {\n    var dummyCanvas = this.dummyCanvas;\n\n    var _context = dummyCanvas.getContext('2d');\n\n    _context.save();\n\n    _context.font = this._getContextFont();\n\n    var metrics = _context.measureText(text);\n\n    _context.restore();\n\n    return {\n      width: metrics.width,\n      height: parseInt(this.attrs.fontSize, 10)\n    };\n  }\n\n  _setTextData() {\n    var that = this;\n\n    var size = this._getTextSize(this.attrs.text);\n\n    var letterSpacing = this.letterSpacing();\n    var align = this.align();\n    var kerningFunc = this.kerningFunc();\n    this.textWidth = size.width;\n    this.textHeight = size.height;\n    var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n    this.glyphInfo = [];\n    var fullPathWidth = 0;\n\n    for (var l = 0; l < that.dataArray.length; l++) {\n      if (that.dataArray[l].pathLength > 0) {\n        fullPathWidth += that.dataArray[l].pathLength;\n      }\n    }\n\n    var offset = 0;\n\n    if (align === 'center') {\n      offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n    }\n\n    if (align === 'right') {\n      offset = Math.max(0, fullPathWidth - textFullWidth);\n    }\n\n    var charArr = stringToArray(this.text());\n    var spacesNumber = this.text().split(' ').length - 1;\n    var p0, p1, pathCmd;\n    var pIndex = -1;\n    var currentT = 0;\n\n    var getNextPathSegment = function () {\n      currentT = 0;\n      var pathData = that.dataArray;\n\n      for (var j = pIndex + 1; j < pathData.length; j++) {\n        if (pathData[j].pathLength > 0) {\n          pIndex = j;\n          return pathData[j];\n        } else if (pathData[j].command === 'M') {\n          p0 = {\n            x: pathData[j].points[0],\n            y: pathData[j].points[1]\n          };\n        }\n      }\n\n      return {};\n    };\n\n    var findSegmentToFitCharacter = function (c) {\n      var glyphWidth = that._getTextSize(c).width + letterSpacing;\n\n      if (c === ' ' && align === 'justify') {\n        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n      }\n\n      var currLen = 0;\n      var attempts = 0;\n      p1 = undefined;\n\n      while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n        attempts++;\n        var cumulativePathLength = currLen;\n\n        while (pathCmd === undefined) {\n          pathCmd = getNextPathSegment();\n\n          if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n            cumulativePathLength += pathCmd.pathLength;\n            pathCmd = undefined;\n          }\n        }\n\n        if (pathCmd === {} || p0 === undefined) {\n          return undefined;\n        }\n\n        var needNewSegment = false;\n\n        switch (pathCmd.command) {\n          case 'L':\n            if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n              p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n            } else {\n              pathCmd = undefined;\n            }\n\n            break;\n\n          case 'A':\n            var start = pathCmd.points[4];\n            var dTheta = pathCmd.points[5];\n            var end = pathCmd.points[4] + dTheta;\n\n            if (currentT === 0) {\n              currentT = start + 0.00000001;\n            } else if (glyphWidth > currLen) {\n              currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n            } else {\n              currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n            }\n\n            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n              currentT = end;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n            break;\n\n          case 'C':\n            if (currentT === 0) {\n              if (glyphWidth > pathCmd.pathLength) {\n                currentT = 0.00000001;\n              } else {\n                currentT = glyphWidth / pathCmd.pathLength;\n              }\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n            } else {\n              currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n            break;\n\n          case 'Q':\n            if (currentT === 0) {\n              currentT = glyphWidth / pathCmd.pathLength;\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n            } else {\n              currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n            break;\n        }\n\n        if (p1 !== undefined) {\n          currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        }\n\n        if (needNewSegment) {\n          needNewSegment = false;\n          pathCmd = undefined;\n        }\n      }\n    };\n\n    var testChar = 'C';\n    var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n    var lettersInOffset = offset / glyphWidth - 1;\n\n    for (var k = 0; k < lettersInOffset; k++) {\n      findSegmentToFitCharacter(testChar);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      p0 = p1;\n    }\n\n    for (var i = 0; i < charArr.length; i++) {\n      findSegmentToFitCharacter(charArr[i]);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n      var kern = 0;\n\n      if (kerningFunc) {\n        try {\n          kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n        } catch (e) {\n          kern = 0;\n        }\n      }\n\n      p0.x += kern;\n      p1.x += kern;\n      this.textWidth += kern;\n      var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n      var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n      this.glyphInfo.push({\n        transposeX: midpoint.x,\n        transposeY: midpoint.y,\n        text: charArr[i],\n        rotation: rotation,\n        p0: p0,\n        p1: p1\n      });\n      p0 = p1;\n    }\n  }\n\n  getSelfRect() {\n    if (!this.glyphInfo.length) {\n      return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    var points = [];\n    this.glyphInfo.forEach(function (info) {\n      points.push(info.p0.x);\n      points.push(info.p0.y);\n      points.push(info.p1.x);\n      points.push(info.p1.y);\n    });\n    var minX = points[0] || 0;\n    var maxX = points[0] || 0;\n    var minY = points[1] || 0;\n    var maxY = points[1] || 0;\n    var x, y;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      x = points[i * 2];\n      y = points[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    var fontSize = this.fontSize();\n    return {\n      x: minX - fontSize / 2,\n      y: minY - fontSize / 2,\n      width: maxX - minX + fontSize,\n      height: maxY - minY + fontSize\n    };\n  }\n\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n\n_registerNode(TextPath);\n\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);","map":{"version":3,"sources":["/Users/stevec/Codeclan_Work/Group_Project/SnakesAndLadders/client/node_modules/konva/lib/shapes/TextPath.js"],"names":["Util","Factory","Shape","Path","Text","stringToArray","getNumberValidator","_registerNode","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","TextPath","constructor","config","dummyCanvas","createCanvasElement","dataArray","parsePathData","attrs","data","on","_setTextData","_sceneFunc","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","_hitFunc","p1","colorKey","getTextWidth","textWidth","getTextHeight","warn","textHeight","setText","prototype","call","_getTextSize","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","letterSpacing","align","kerningFunc","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","getSelfRect","forEach","info","minX","maxX","minY","maxY","min","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","addGetterSetter"],"mappings":"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","sourcesContent":["import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n"]},"metadata":{},"sourceType":"module"}